Voici un README.md complet pour votre projet :

```markdown
# Bit Packing Compression - Software Engineering Project 2025

**Auteur** : RemiM06

Projet de compression d'entiers utilisant la technique du Bit Packing pour accÃ©lÃ©rer les transmissions rÃ©seau.

---

## ğŸ“‹ Table des matiÃ¨res

1. [Description du projet](#description-du-projet)
2. [PrÃ©requis](#prÃ©requis)
3. [Installation](#installation)
4. [Utilisation](#utilisation)
5. [StratÃ©gies de compression](#stratÃ©gies-de-compression)
6. [Architecture du code](#architecture-du-code)
7. [RÃ©sultats des benchmarks](#rÃ©sultats-des-benchmarks)

---

## ğŸ¯ Description du projet

Ce projet implÃ©mente plusieurs stratÃ©gies de compression d'entiers basÃ©es sur le **Bit Packing** :

- **Overlap** : Les entiers compressÃ©s peuvent chevaucher deux int32 consÃ©cutifs
- **No-Overlap** : Chaque entier compressÃ© reste dans un seul int32
- **Overflow** : Utilise une zone de dÃ©bordement pour les valeurs exceptionnelles

L'objectif est de rÃ©duire la taille des tableaux d'entiers transmis sur le rÃ©seau, tout en conservant un **accÃ¨s direct** aux Ã©lÃ©ments (fonction `get(i)` sans dÃ©compression complÃ¨te).

---

## ğŸ”§ PrÃ©requis

- **Java** : JDK 20 ou supÃ©rieur
- **Maven** : 3.6+ (pour la compilation)

---

## ğŸ“¦ Installation

### 1. Cloner le dÃ©pÃ´t

```bash
git clone <votre-url-github>
cd SoftwareEngineering-DataCompressing
```

### 2. Compiler le projet

```bash
mvn clean compile
```

---

## ğŸš€ Utilisation

### ExÃ©cution du programme principal

```bash
mvn exec:java -Dexec.mainClass="org.example.Main"
```

### Sortie attendue

Le programme affiche :
- Comparaison des performances entre les stratÃ©gies
- Temps de compression, dÃ©compression et accÃ¨s `get()`
- Analyse de rentabilitÃ© pour la transmission rÃ©seau

---

## ğŸ“– Utilisation dans votre code

### Exemple 1 : Compression simple avec Overlap

```java
import org.example.*;

public class Example {
    public static void main(String[] args) {
        int[] data = {1, 2, 3, 1024, 4, 5};
        
        // CrÃ©er un compresseur avec chevauchement
        BitPacking bp = BitPackingFactory.create(CompressionType.OVERLAP);
        
        // Compresser
        int[] compressed = bp.compress(data);
        System.out.println("Taille compressÃ©e : " + bp.getCompressedSize());
        System.out.println("Ratio : " + bp.getCompressionRatio());
        
        // AccÃ¨s direct au 3e Ã©lÃ©ment (sans dÃ©compression)
        int value = bp.get(2);
        System.out.println("data[2] = " + value);
        
        // DÃ©compression complÃ¨te
        int[] decompressed = bp.decompress();
    }
}
```

### Exemple 2 : Compression sans chevauchement

```java
BitPacking bp = BitPackingFactory.create(CompressionType.NO_OVERLAP);
int[] compressed = bp.compress(data);
```

### Exemple 3 : Compression avec overflow

```java
BitPacking bp = BitPackingFactory.create(CompressionType.OVERFLOW);
int[] compressed = bp.compress(data);
```

---

## ğŸ” StratÃ©gies de compression

### 1. **Overlap** (avec chevauchement)

**Principe** : Utilise chaque bit disponible, mÃªme si cela signifie que certains entiers s'Ã©tendent sur deux int32.

**Avantages** :
- Meilleur ratio de compression (15% supÃ©rieur)
- Pas de bits perdus (padding minimal)

**InconvÃ©nients** :
- Compression plus lente (3x)
- Code plus complexe

**Exemple** : Pour 6 entiers sur 12 bits chacun :
```
int32[0] : Ã©lÃ©ment 0 (bits 0-11), Ã©lÃ©ment 1 (bits 12-23), Ã©lÃ©ment 2 (bits 24-31 + overflow)
int32[1] : Ã©lÃ©ment 2 (bits 0-3), Ã©lÃ©ment 3 (bits 4-15), Ã©lÃ©ment 4 (bits 16-27), Ã©lÃ©ment 5 (bits 28-31 + overflow)
int32[2] : Ã©lÃ©ment 5 (bits 0-7)
```

---

### 2. **No-Overlap** (sans chevauchement)

**Principe** : Chaque entier compressÃ© reste dans un seul int32, quitte Ã  laisser des bits inutilisÃ©s.

**Avantages** :
- Compression 3x plus rapide
- Code plus simple
- AccÃ¨s plus direct

**InconvÃ©nients** :
- Moins bon ratio (padding obligatoire)

**Exemple** : Pour 6 entiers sur 12 bits chacun :
```
int32[0] : Ã©lÃ©ment 0 (bits 0-11), Ã©lÃ©ment 1 (bits 12-23), [8 bits inutilisÃ©s]
int32[1] : Ã©lÃ©ment 2 (bits 0-11), Ã©lÃ©ment 3 (bits 12-23), [8 bits inutilisÃ©s]
int32[2] : Ã©lÃ©ment 4 (bits 0-11), Ã©lÃ©ment 5 (bits 12-23), [8 bits inutilisÃ©s]
```

---

### 3. **Overflow** (avec zone de dÃ©bordement)

**Principe** : Compresse les valeurs "normales" avec peu de bits, et stocke les outliers dans une zone sÃ©parÃ©e.

**Exemple** : Pour `[1, 2, 3, 1024, 4, 5, 2048]` :
- Seuil : 90e percentile (ici, 5)
- Zone principale : `[0-1, 0-2, 0-3, 1-0, 0-4, 0-5, 1-1]` (3 bits + 1 bit flag)
- Zone overflow : `[1024, 2048]`

---

## ğŸ—ï¸ Architecture du code

```
src/main/java/org/example/
â”œâ”€â”€ BitPacking.java               # Interface commune
â”œâ”€â”€ BitPackingOverlap.java        # ImplÃ©mentation avec chevauchement
â”œâ”€â”€ BitPackingNoOverlap.java      # ImplÃ©mentation sans chevauchement
â”œâ”€â”€ BitPackingOverflow.java       # ImplÃ©mentation avec overflow
â”œâ”€â”€ BitPackingFactory.java        # Factory pour crÃ©er les instances
â”œâ”€â”€ CompressionType.java          # Enum des types
â”œâ”€â”€ BitPackingUtils.java          # Utilitaires (calcul de bits)
â”œâ”€â”€ BitPackingBenchmark.java      # Tests de performance
â”œâ”€â”€ TransmissionAnalysis.java     # Calcul de rentabilitÃ©
â””â”€â”€ Main.java                     # Point d'entrÃ©e
```

---

## ğŸ“Š RÃ©sultats des benchmarks

**Dataset** : 10 000 entiers (95% entre 0-100, 5% outliers ~10 000)

| MÃ©trique           | Overlap  | NoOverlap | Gagnant   |
|--------------------|----------|-----------|-----------|
| Temps compression  | 2406 Âµs  | 835 Âµs    | NoOverlap |
| Temps dÃ©compression| 918 Âµs   | 654 Âµs    | NoOverlap |
| Temps get() moyen  | 110 ns   | 114 ns    | Similaire |
| Ratio compression  | 2.29     | 2.00      | Overlap   |
| Seuil rentabilitÃ©  | 0.097 Âµs | 0.095 Âµs  | Similaire |

### InterprÃ©tation

**Quand utiliser NoOverlap ?**
- Compressions frÃ©quentes (3x plus rapide)
- Applications temps rÃ©el
- Ressources CPU limitÃ©es

**Quand utiliser Overlap ?**
- Bande passante limitÃ©e (15% d'Ã©conomie)
- Transmissions longue distance
- Stockage long terme

---

## ğŸ“„ Licence

Projet acadÃ©mique - UniversitÃ© Nice Sophia Antipolis - 2025

---

## ğŸ“§ Contact

**Auteur** : Remi Mathieu
**Email du professeur** : jcregin@gmail.com
```
